# src/license_plate_dataset.py

import os
import h5py
import torch
from torch.utils.data import Dataset
from PIL import Image
import json


class LicensePlateDataset(Dataset):
    def __init__(self, image_source, transform=None):
        """
        image_source: either a path to a .h5 file generated by lp_processing,
                      or a directory containing original_*.png, distorted_*.png, metadata_*.json.
        transform: torchvision transforms to apply to each image
        """
        self.transform = transform

        if os.path.isfile(image_source) and image_source.lower().endswith(".h5"):
            # --- HDF5 mode: load everything into RAM once ---
            with h5py.File(image_source, "r") as h5:
                # each dataset is (N, H, W, 3) or (N, ) or (N, D, 4)
                self._orig_np = h5["original"][:]  # uint8 H×W×3
                self._dist_np = h5["distorted"][:]  # uint8 H×W×3
                self.plate_nums = h5["plate_number"][:]  # bytestrings
                self.alphas = h5["alpha"][:]  # floats
                self.betas = h5["beta"][:]  # floats
                self.bboxes = h5["digit_bboxes"][:]  # int (N, digits, 4)
            self._mode = "h5"

        elif os.path.isdir(image_source):
            # --- folder mode: keep listing on disk ---
            self.image_dir = image_source
            self.indices = self._get_indices()
            self._mode = "folder"

        else:
            raise ValueError(f"image_source must be a .h5 file or an existing directory (got {image_source})")

    def _get_indices(self):
        files = os.listdir(self.image_dir)
        # find all original_{idx}.png files
        idxs = {int(f.split("_")[1].split(".")[0]) for f in files if f.startswith("original_") and f.endswith(".png")}
        return sorted(idxs)

    def __len__(self):
        if self._mode == "h5":
            return self._orig_np.shape[0]
        return len(self.indices)

    def __getitem__(self, idx):
        if self._mode == "h5":
            # pull from in-RAM NumPy arrays
            orig = self._orig_np[idx]  # H×W×3 uint8
            dist = self._dist_np[idx]
            meta = {
                "plate_number": self.plate_nums[idx].astype(str),
                "alpha": float(self.alphas[idx]),
                "beta": float(self.betas[idx]),
                "digit_bboxes": self.bboxes[idx].tolist(),
            }

        else:
            # folder mode: load from disk
            actual = self.indices[idx]
            orig_path = os.path.join(self.image_dir, f"original_{actual}.png")
            dist_path = os.path.join(self.image_dir, f"distorted_{actual}.png")
            meta_path = os.path.join(self.image_dir, f"metadata_{actual}.json")

            orig = Image.open(orig_path).convert("RGB")
            dist = Image.open(dist_path).convert("RGB")
            with open(meta_path, "r") as f:
                m = json.load(f)
            meta = {
                "plate_number": m["plate_number"],
                "alpha": m["alpha"],
                "beta": m["beta"],
                "digit_bboxes": m["digit_bboxes"],
            }

        # apply transforms (ToTensor, normalization, etc.)
        if self.transform:
            # torchvision transforms accept both PIL Images or H×W×C NumPy arrays
            orig = self.transform(orig)
            dist = self.transform(dist)
        else:
            # fallback: convert NumPy -> torch tensor in [0,1]
            orig = torch.from_numpy(orig).permute(2, 0, 1).float().div(255)
            dist = torch.from_numpy(dist).permute(2, 0, 1).float().div(255)

        return {"original": orig, "distorted": dist, "metadata": meta}
